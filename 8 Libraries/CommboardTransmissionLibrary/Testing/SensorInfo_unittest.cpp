#include "SensorInfo.h"
#include "gtest/gtest.h"
#include "misc/BinaryBuffer/BinaryBuffer.h"
#include "boost/endian/arithmetic.hpp"
#include <cmath>
#include <iostream>

using namespace cmbtl;

// DISCLAIMER: These unit tests were generated by AI but reviewed and modified by a human.

// Tests for defaultEncode and defaultDecode
TEST(SensorInfoFunctionsTests, DefaultEncodeDecodeInteger) {
    // Test with different integer types
    {
        BinaryBuffer buffer(32);
        boost::endian::big_uint32_t value = 12345;
        defaultEncode<boost::endian::big_uint32_t, 32>(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        boost::endian::big_uint32_t decodedValue = defaultDecode<boost::endian::big_uint32_t, 32>(buffer);
        ASSERT_EQ(decodedValue, value);
    }
    
    // Test with different bit sizes
    {
        BinaryBuffer buffer(16);
        boost::endian::big_uint16_t value = 255;
        defaultEncode<boost::endian::big_uint16_t, 16>(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        boost::endian::big_uint16_t decodedValue = defaultDecode<boost::endian::big_uint16_t, 16>(buffer);
        ASSERT_EQ(decodedValue, value);
    }
}

TEST(SensorInfoFunctionsTests, DefaultEncodeDecodeFloat) {
    BinaryBuffer buffer(32);
    boost::endian::big_float32_t value = 123.456f;
    defaultEncode<boost::endian::big_float32_t, 32>(value, buffer);
    
    // Reset read cursor
    buffer.resetReadCursorPos();
    
    boost::endian::big_float32_t decodedValue = defaultDecode<boost::endian::big_float32_t, 32>(buffer);
    ASSERT_FLOAT_EQ(decodedValue, value);
}

// Tests for defaultConvert
TEST(SensorInfoFunctionsTests, DefaultConvert) {
    // Test converting between different types
    boost::endian::big_uint32_t intValue = 42;
    float floatValue = defaultConvert<boost::endian::big_uint32_t, float>(intValue);
    ASSERT_FLOAT_EQ(floatValue, 42.0f);
    
    // Test converting between same types
    boost::endian::big_uint16_t uint16Value = 100;
    boost::endian::big_uint16_t sameValue = defaultConvert<boost::endian::big_uint16_t>(uint16Value);
    ASSERT_EQ(sameValue, uint16Value);
}

// Tests for boolEncode and boolDecode
TEST(SensorInfoFunctionsTests, BoolEncodeDecode) {
    // Test true value
    {
        BinaryBuffer buffer(1);
        bool value = true;
        boolEncode(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        bool decodedValue = boolDecode(buffer);
        ASSERT_EQ(decodedValue, value);
    }
    
    // Test false value
    {
        BinaryBuffer buffer(1);
        bool value = false;
        boolEncode(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        bool decodedValue = boolDecode(buffer);
        ASSERT_EQ(decodedValue, value);
    }
}

// Tests for unsignedFloatEncode and unsignedFloatDecode
TEST(SensorInfoFunctionsTests, UnsignedFloatEncodeDecode) {
    constexpr uint8_t DECIMAL_BITS = 6;
    constexpr size_t ENCODED_BIT_SIZE = 20;
    const float precision = 1.0f / std::pow(2, DECIMAL_BITS);
    
    // Test exact representable value
    {
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        // 10.5 = 10 + 32/64 with DECIMAL_BITS = 6
        float value = 10.5f;
        unsignedFloatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        float decodedValue = unsignedFloatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        ASSERT_FLOAT_EQ(decodedValue, value);
    }
    
    // Test value that needs rounding
    {
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = 15.1234f;
        unsignedFloatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        float decodedValue = unsignedFloatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        
        // Calculate expected rounded value
        uint64_t encodedRoundedValue = std::round(value * std::pow(2, DECIMAL_BITS));
        float expectedRoundedValue = encodedRoundedValue / std::pow(2, DECIMAL_BITS);
        
        ASSERT_FLOAT_EQ(decodedValue, expectedRoundedValue);
        ASSERT_NEAR(decodedValue, value, precision);
    }
    
    // Test zero value
    {
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = 0.0f;
        unsignedFloatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        float decodedValue = unsignedFloatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        ASSERT_FLOAT_EQ(decodedValue, value);
    }
    
    // Test large value
    {
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = 1000.25f;
        unsignedFloatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        float decodedValue = unsignedFloatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        ASSERT_FLOAT_EQ(decodedValue, value);
    }
}

// Tests for floatEncode and floatDecode
TEST(SensorInfoFunctionsTests, FloatEncodeDecode) {
    constexpr uint8_t DECIMAL_BITS = 6;
    constexpr size_t ENCODED_BIT_SIZE = 21; // 20 bits + 1 sign bit
    const float precision = 1.0f / std::pow(2, DECIMAL_BITS);
    
    // Test positive value
    {
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = 25.75f;
        floatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        float decodedValue = floatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        ASSERT_FLOAT_EQ(decodedValue, value);
    }
    
    // Test negative value
    {
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = -17.25f;

        floatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        buffer.resetWriteCursorPos();

        buffer.resetReadCursorPos();

        float decodedValue = floatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        ASSERT_FLOAT_EQ(decodedValue, value);
    }
    
    // Test zero value
    {
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = 0.0f;
        floatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        float decodedValue = floatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        ASSERT_FLOAT_EQ(decodedValue, value);
    }
    
    // Test value that requires rounding
    {
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = -42.123f;
        floatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        // Reset read cursor
        buffer.resetReadCursorPos();
        
        float decodedValue = floatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        
        // Calculate expected rounded value (need to handle negative values properly)
        uint64_t encodedRoundedValue = std::round(std::abs(value) * std::pow(2, DECIMAL_BITS));
        float expectedRoundedValue = -1.0f * (encodedRoundedValue / std::pow(2, DECIMAL_BITS));
        
        ASSERT_FLOAT_EQ(decodedValue, expectedRoundedValue);
        ASSERT_NEAR(decodedValue, value, precision);
    }
}

// Test for different DECIMAL_BITS values
TEST(SensorInfoFunctionsTests, FloatPrecisionVariation) {
    // Test with low precision (DECIMAL_BITS = 2)
    {
        constexpr uint8_t DECIMAL_BITS = 2;
        constexpr size_t ENCODED_BIT_SIZE = 10;
        
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = 25.3f; // Not exactly representable with 2 decimal bits
        unsignedFloatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        buffer.resetReadCursorPos();
        float decodedValue = unsignedFloatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        
        // With DECIMAL_BITS = 2, precision is 0.25
        ASSERT_NEAR(decodedValue, value, 0.25f);
    }
    
    // Test with high precision (DECIMAL_BITS = 10)
    {
        constexpr uint8_t DECIMAL_BITS = 10;
        constexpr size_t ENCODED_BIT_SIZE = 20;
        
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = 30.0012f; // Very fine precision
        unsignedFloatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        buffer.resetReadCursorPos();
        float decodedValue = unsignedFloatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        
        // With DECIMAL_BITS = 10, precision is about 0.001
        ASSERT_NEAR(decodedValue, value, 0.001f);
    }
}

// Test for range limits based on ENCODED_BIT_SIZE
TEST(SensorInfoFunctionsTests, FloatRangeLimits) {
    constexpr uint8_t DECIMAL_BITS = 6;
    
    // Test with small bit size
    {
        constexpr size_t ENCODED_BIT_SIZE = 8; // Very small, can only represent values up to 2^(8-6) = 4
        
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = 3.5f; // Should fit within range
        unsignedFloatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        buffer.resetReadCursorPos();
        float decodedValue = unsignedFloatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        
        ASSERT_FLOAT_EQ(decodedValue, value);
    }
    
    // Test with larger bit size
    {
        constexpr size_t ENCODED_BIT_SIZE = 16; // Can represent values up to 2^(16-6) = 1024
        
        BinaryBuffer buffer(ENCODED_BIT_SIZE);
        float value = 1000.25f; // Should fit within range
        unsignedFloatEncode<ENCODED_BIT_SIZE, DECIMAL_BITS>(value, buffer);
        
        buffer.resetReadCursorPos();
        float decodedValue = unsignedFloatDecode<ENCODED_BIT_SIZE, DECIMAL_BITS>(buffer);
        
        ASSERT_FLOAT_EQ(decodedValue, value);
    }
}

// Test for different DECIMAL_BITS combinations
TEST(SensorInfoFunctionsTests, VariablePrecisionTest) {
    // Create a test matrix with different precision settings
    struct TestCase {
        uint8_t decimalBits;
        size_t encodedBitSize;
        float testValue;
    };
    
    TestCase testCases[] = {
        {3, 10, 5.125f},    // 3 decimal bits = 0.125 precision
        {4, 12, 7.0625f},   // 4 decimal bits = 0.0625 precision
        {5, 14, 9.03125f},  // 5 decimal bits = 0.03125 precision
        {8, 17, 8.00390625f} // 8 decimal bits = 0.00390625 precision
    };
    
    for (const auto& tc : testCases) {
        BinaryBuffer buffer(tc.encodedBitSize);
        float precision = 1.0f / std::pow(2, tc.decimalBits);
        
        // Use template specialization to call the right function for each test case
        switch (tc.decimalBits) {
            case 3:
                unsignedFloatEncode<10, 3>(tc.testValue, buffer);
                buffer.resetReadCursorPos();
                ASSERT_FLOAT_EQ((unsignedFloatDecode<10, 3>(buffer)), tc.testValue);
                break;
            case 4:
                unsignedFloatEncode<12, 4>(tc.testValue, buffer);
                buffer.resetReadCursorPos();
                ASSERT_FLOAT_EQ((unsignedFloatDecode<12, 4>(buffer)), tc.testValue);
                break;
            case 5:
                unsignedFloatEncode<14, 5>(tc.testValue, buffer);
                buffer.resetReadCursorPos();
                ASSERT_FLOAT_EQ((unsignedFloatDecode<14, 5>(buffer)), tc.testValue);
                break;
            case 8:
                unsignedFloatEncode<17, 8>(tc.testValue, buffer);
                buffer.resetReadCursorPos();
                ASSERT_FLOAT_EQ((unsignedFloatDecode<17, 8>(buffer)), tc.testValue);
                break;
        }
    }
}